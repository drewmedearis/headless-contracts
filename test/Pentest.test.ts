import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

/**
 * PENETRATION TEST SUITE
 *
 * Simulates adversarial attacks that hackers would attempt:
 * - Zero value attacks
 * - Max value overflow attacks
 * - Invalid parameter attacks
 * - Unauthorized access attempts
 * - State manipulation attacks
 * - Economic exploitation attempts
 */
describe("Penetration Tests (Adversarial)", function () {
  async function deployFixture() {
    const [owner, treasury, attacker, victim, agent1, agent2, agent3] =
      await ethers.getSigners();

    const Factory = await ethers.getContractFactory("BondingCurveFactory");
    const factory = await Factory.deploy(treasury.address, ethers.ZeroAddress);

    const Governance = await ethers.getContractFactory("QuorumGovernance");
    const governance = await Governance.deploy(factory.target);

    await factory.setGovernance(governance.target);

    // Create test market
    await factory.createMarket(
      [agent1.address, agent2.address, agent3.address],
      [40, 35, 25],
      "Test Token",
      "TEST",
      "Test thesis"
    );

    const market = await factory.getMarket(0);
    const token = await ethers.getContractAt("MarketToken", market.tokenAddress);

    return { factory, governance, token, owner, treasury, attacker, victim, agent1, agent2, agent3 };
  }

  // ============ ZERO VALUE ATTACKS ============
  describe("Zero Value Attacks", function () {
    it("ATTACK: Buy with 0 ETH - should fail", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      await expect(
        factory.connect(attacker).buy(0, 0, { value: 0 })
      ).to.be.revertedWith("Below minimum purchase");
    });

    it("ATTACK: Sell 0 tokens - should fail", async function () {
      const { factory, token, attacker } = await loadFixture(deployFixture);

      // Buy first
      await factory.connect(attacker).buy(0, 0, { value: ethers.parseEther("1.0") });
      await token.connect(attacker).approve(factory.target, ethers.MaxUint256);

      await expect(
        factory.connect(attacker).sell(0, 0, 0)
      ).to.be.revertedWith("Zero tokens");
    });

    it("ATTACK: Set protocol fee to 0 - should succeed (design decision)", async function () {
      const { factory, owner, attacker, victim } = await loadFixture(deployFixture);

      // Owner can set fee to 0 (free trading period)
      await factory.connect(owner).setProtocolFeeBps(0);

      const treasuryBefore = await ethers.provider.getBalance(await factory.protocolTreasury());
      await factory.connect(victim).buy(0, 0, { value: ethers.parseEther("1.0") });
      const treasuryAfter = await ethers.provider.getBalance(await factory.protocolTreasury());

      // No fee collected
      expect(treasuryAfter).to.equal(treasuryBefore);
    });

    it("ATTACK: Emergency withdraw 0 ETH - should succeed (no-op)", async function () {
      const { factory, owner } = await loadFixture(deployFixture);

      // Send extra ETH first
      await owner.sendTransaction({ to: factory.target, value: ethers.parseEther("1.0") });

      // Withdraw 0 should work (but do nothing)
      await expect(factory.connect(owner).emergencyWithdrawETH(0)).to.not.be.reverted;
    });

    it("ATTACK: Set base price to 0 - should fail", async function () {
      const { factory, owner } = await loadFixture(deployFixture);

      await expect(
        factory.connect(owner).setDefaultParameters(0, 0, ethers.parseEther("10"))
      ).to.be.revertedWith("Invalid base price");
    });

    it("ATTACK: Set target raise to 0 - should fail", async function () {
      const { factory, owner } = await loadFixture(deployFixture);

      await expect(
        factory.connect(owner).setDefaultParameters(ethers.parseEther("0.0001"), 0, 0)
      ).to.be.revertedWith("Invalid target raise");
    });
  });

  // ============ MAX VALUE / OVERFLOW ATTACKS ============
  describe("Max Value / Overflow Attacks", function () {
    it("ATTACK: Buy with max uint256 ETH - limited by actual balance", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      // Can't send more ETH than you have
      const attackerBalance = await ethers.provider.getBalance(attacker.address);

      // This will fail with insufficient funds before reaching contract
      await expect(
        factory.connect(attacker).buy(0, 0, { value: ethers.MaxUint256 })
      ).to.be.rejected; // Transaction will fail
    });

    it("ATTACK: Sell max uint256 tokens - should fail", async function () {
      const { factory, token, attacker } = await loadFixture(deployFixture);

      await factory.connect(attacker).buy(0, 0, { value: ethers.parseEther("1.0") });
      await token.connect(attacker).approve(factory.target, ethers.MaxUint256);

      const attackerBalance = await token.balanceOf(attacker.address);

      // Try to sell more than owned
      await expect(
        factory.connect(attacker).sell(0, ethers.MaxUint256, 0)
      ).to.be.reverted; // ERC20 insufficient balance
    });

    it("ATTACK: Set fee to max uint256 - should fail (max 500 = 5%)", async function () {
      const { factory, owner } = await loadFixture(deployFixture);

      await expect(
        factory.connect(owner).setProtocolFeeBps(ethers.MaxUint256)
      ).to.be.revertedWith("Fee too high");
    });

    it("ATTACK: Request minTokensOut as max uint256 - slippage fails", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      await expect(
        factory.connect(attacker).buy(0, ethers.MaxUint256, { value: ethers.parseEther("1.0") })
      ).to.be.revertedWith("Slippage exceeded");
    });

    it("ATTACK: Request minEthOut as max uint256 - slippage fails", async function () {
      const { factory, token, attacker } = await loadFixture(deployFixture);

      await factory.connect(attacker).buy(0, 0, { value: ethers.parseEther("1.0") });
      const balance = await token.balanceOf(attacker.address);
      await token.connect(attacker).approve(factory.target, balance);

      await expect(
        factory.connect(attacker).sell(0, balance, ethers.MaxUint256)
      ).to.be.revertedWith("Slippage exceeded");
    });
  });

  // ============ INVALID MARKET ID ATTACKS ============
  describe("Invalid Market ID Attacks", function () {
    it("ATTACK: Buy from non-existent market - should fail", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      await expect(
        factory.connect(attacker).buy(999, 0, { value: ethers.parseEther("1.0") })
      ).to.be.revertedWith("Market not active");
    });

    it("ATTACK: Sell to non-existent market - should fail", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      await expect(
        factory.connect(attacker).sell(999, 1000, 0)
      ).to.be.revertedWith("Market not active");
    });

    it("ATTACK: Emergency pause non-existent market - should fail", async function () {
      const { factory, owner } = await loadFixture(deployFixture);

      await expect(
        factory.connect(owner).emergencyPause(999)
      ).to.be.revertedWith("Market not active");
    });

    it("ATTACK: Force graduate non-existent market - should fail", async function () {
      const { factory, governance, attacker } = await loadFixture(deployFixture);

      // Even governance can't force graduate non-existent market
      // (attacker would need to be governance contract)
      await expect(
        factory.connect(attacker).forceGraduate(999)
      ).to.be.revertedWith("Only governance");
    });

    it("ATTACK: Rescue non-existent market - should fail", async function () {
      const { factory, owner } = await loadFixture(deployFixture);

      await expect(
        factory.connect(owner).rescueGraduatedMarketFunds(999)
      ).to.be.revertedWith("Market not graduated");
    });
  });

  // ============ UNAUTHORIZED ACCESS ATTACKS ============
  describe("Unauthorized Access Attacks", function () {
    it("ATTACK: Non-owner sets treasury - should fail", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      await expect(
        factory.connect(attacker).setProtocolTreasury(attacker.address)
      ).to.be.revertedWithCustomError(factory, "OwnableUnauthorizedAccount");
    });

    it("ATTACK: Non-owner sets fee - should fail", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      await expect(
        factory.connect(attacker).setProtocolFeeBps(500)
      ).to.be.revertedWithCustomError(factory, "OwnableUnauthorizedAccount");
    });

    it("ATTACK: Non-owner emergency withdraws ETH - should fail", async function () {
      const { factory, owner, attacker } = await loadFixture(deployFixture);

      await owner.sendTransaction({ to: factory.target, value: ethers.parseEther("1.0") });

      await expect(
        factory.connect(attacker).emergencyWithdrawETH(ethers.parseEther("1.0"))
      ).to.be.revertedWithCustomError(factory, "OwnableUnauthorizedAccount");
    });

    it("ATTACK: Non-owner emergency withdraws tokens - should fail", async function () {
      const { factory, token, attacker } = await loadFixture(deployFixture);

      await expect(
        factory.connect(attacker).emergencyWithdrawTokens(token.target, 1000)
      ).to.be.revertedWithCustomError(factory, "OwnableUnauthorizedAccount");
    });

    it("ATTACK: Non-owner sets governance - should fail", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      await expect(
        factory.connect(attacker).setGovernance(attacker.address)
      ).to.be.revertedWithCustomError(factory, "OwnableUnauthorizedAccount");
    });

    it("ATTACK: Non-owner sets Uniswap router - should fail", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      await expect(
        factory.connect(attacker).setUniswapRouter(attacker.address)
      ).to.be.revertedWithCustomError(factory, "OwnableUnauthorizedAccount");
    });

    it("ATTACK: Non-owner pauses market - should fail", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      await expect(
        factory.connect(attacker).requestPause(0)
      ).to.be.revertedWithCustomError(factory, "OwnableUnauthorizedAccount");

      await expect(
        factory.connect(attacker).emergencyPause(0)
      ).to.be.revertedWithCustomError(factory, "OwnableUnauthorizedAccount");
    });

    it("ATTACK: Non-governance force graduates - should fail", async function () {
      const { factory, attacker, victim } = await loadFixture(deployFixture);

      await factory.connect(victim).buy(0, 0, { value: ethers.parseEther("1.0") });

      await expect(
        factory.connect(attacker).forceGraduate(0)
      ).to.be.revertedWith("Only governance");
    });
  });

  // ============ STATE MANIPULATION ATTACKS ============
  describe("State Manipulation Attacks", function () {
    it("ATTACK: Double-spend via rapid buy/sell - prevented by state updates", async function () {
      const { factory, token, attacker } = await loadFixture(deployFixture);

      // Buy tokens
      await factory.connect(attacker).buy(0, 0, { value: ethers.parseEther("1.0") });
      const balance = await token.balanceOf(attacker.address);
      await token.connect(attacker).approve(factory.target, balance);

      // Sell all
      await factory.connect(attacker).sell(0, balance, 0);

      // Try to sell again - should fail (no tokens)
      await expect(
        factory.connect(attacker).sell(0, balance, 0)
      ).to.be.reverted; // ERC20 insufficient balance
    });

    it("ATTACK: Sell tokens never purchased from curve - should fail", async function () {
      const { factory, token, agent1, attacker } = await loadFixture(deployFixture);

      // Agent1 has tokens from quorum allocation (not from curve)
      const agent1Balance = await token.balanceOf(agent1.address);
      expect(agent1Balance).to.be.gt(0);

      // Transfer tokens to attacker
      await token.connect(agent1).transfer(attacker.address, agent1Balance);
      await token.connect(attacker).approve(factory.target, agent1Balance);

      // Try to sell - should fail because tokensSold < requested
      const market = await factory.getMarket(0);
      expect(market.tokensSold).to.equal(0); // Nothing sold from curve yet

      await expect(
        factory.connect(attacker).sell(0, agent1Balance, 0)
      ).to.be.revertedWith("Not enough tokens sold");
    });

    it("ATTACK: Buy from paused market - should fail", async function () {
      const { factory, owner, attacker } = await loadFixture(deployFixture);

      await factory.connect(owner).emergencyPause(0);

      await expect(
        factory.connect(attacker).buy(0, 0, { value: ethers.parseEther("1.0") })
      ).to.be.revertedWith("Market not active");
    });

    it("ATTACK: Buy from graduated market - should fail", async function () {
      const { factory, victim, attacker } = await loadFixture(deployFixture);

      // Graduate market
      await factory.connect(victim).buy(0, 0, { value: ethers.parseEther("11.0") });

      const market = await factory.getMarket(0);
      expect(market.graduated).to.be.true;

      await expect(
        factory.connect(attacker).buy(0, 0, { value: ethers.parseEther("1.0") })
      ).to.be.revertedWith("Market graduated");
    });

    it("ATTACK: Rescue non-graduated market funds - should fail", async function () {
      const { factory, owner, victim } = await loadFixture(deployFixture);

      await factory.connect(victim).buy(0, 0, { value: ethers.parseEther("1.0") });

      // Market not graduated yet
      await expect(
        factory.connect(owner).rescueGraduatedMarketFunds(0)
      ).to.be.revertedWith("Market not graduated");
    });
  });

  // ============ ECONOMIC EXPLOITATION ATTACKS ============
  describe("Economic Exploitation Attacks", function () {
    it("ATTACK: Drain contract via emergency withdraw - prevented by reserve check", async function () {
      const { factory, owner, victim } = await loadFixture(deployFixture);

      // Victim buys tokens (adds ETH to contract)
      await factory.connect(victim).buy(0, 0, { value: ethers.parseEther("5.0") });

      const market = await factory.getMarket(0);
      const reserved = market.currentRaised;

      // Owner tries to drain all contract ETH
      await expect(
        factory.connect(owner).emergencyWithdrawETH(reserved)
      ).to.be.revertedWith("Amount exceeds withdrawable");

      // Only excess (above reserved) can be withdrawn
      await owner.sendTransaction({ to: factory.target, value: ethers.parseEther("1.0") });
      await expect(
        factory.connect(owner).emergencyWithdrawETH(ethers.parseEther("1.0"))
      ).to.not.be.reverted;
    });

    it("ATTACK: Sandwich attack mitigated by slippage protection", async function () {
      const { factory, attacker, victim } = await loadFixture(deployFixture);

      // Attacker front-runs
      await factory.connect(attacker).buy(0, 0, { value: ethers.parseEther("3.0") });

      // Victim sets strict slippage
      const expectedTokens = await factory.calculatePurchaseReturn(0, ethers.parseEther("1.0"));

      // If attacker moved price, victim's tx fails
      await expect(
        factory.connect(victim).buy(0, expectedTokens + 1n, { value: ethers.parseEther("1.0") })
      ).to.be.revertedWith("Slippage exceeded");
    });

    it("ATTACK: Extract more ETH than deposited via sell - prevented", async function () {
      const { factory, token, attacker } = await loadFixture(deployFixture);

      const buyAmount = ethers.parseEther("1.0");
      await factory.connect(attacker).buy(0, 0, { value: buyAmount });

      const tokens = await token.balanceOf(attacker.address);
      await token.connect(attacker).approve(factory.target, tokens);

      const ethBefore = await ethers.provider.getBalance(attacker.address);
      const tx = await factory.connect(attacker).sell(0, tokens, 0);
      const receipt = await tx.wait();
      const gasUsed = receipt!.gasUsed * receipt!.gasPrice;
      const ethAfter = await ethers.provider.getBalance(attacker.address);

      // Due to fees, attacker gets less back than they put in
      const netReturn = ethAfter - ethBefore + gasUsed;
      const fee = (buyAmount * 50n) / 10000n; // 0.5% fee on buy

      // Attacker can't profit from round-trip (fees ensure loss)
      expect(netReturn).to.be.lt(buyAmount);
    });

    it("ATTACK: Grief by creating many markets - costs ETH", async function () {
      const { factory, attacker, agent1, agent2, agent3 } = await loadFixture(deployFixture);

      // Attacker tries to spam market creation
      // This costs gas but markets are useless without quorum approval
      const balanceBefore = await ethers.provider.getBalance(attacker.address);

      for (let i = 0; i < 3; i++) {
        await factory.connect(attacker).createMarket(
          [agent1.address, agent2.address, agent3.address],
          [34, 33, 33],
          `Spam Token ${i}`,
          `SPAM${i}`,
          "Spam thesis"
        );
      }

      const balanceAfter = await ethers.provider.getBalance(attacker.address);

      // Attacker spent gas, markets exist but require legitimate quorum
      expect(balanceAfter).to.be.lt(balanceBefore);
    });
  });

  // ============ GOVERNANCE ATTACKS ============
  describe("Governance Attacks", function () {
    it("ATTACK: Non-member votes on proposal - should fail", async function () {
      const { governance, agent1, agent2, agent3, attacker, victim } = await loadFixture(deployFixture);

      // Create quorum
      await governance.connect(agent1).proposeQuorum(
        [agent1.address, agent2.address, agent3.address],
        [34, 33, 33],
        "Gov Test",
        "GOVTEST",
        "Gov thesis"
      );
      await governance.connect(agent2).approveQuorum(0);
      await governance.connect(agent3).approveQuorum(0);

      // Create proposal
      await governance.connect(agent1).propose(1, 0, victim.address, 10, "0x", "Add victim");

      // Attacker (non-member) tries to vote
      await expect(
        governance.connect(attacker).vote(0, true)
      ).to.be.revertedWith("Not quorum member");
    });

    it("ATTACK: Double vote - should fail", async function () {
      const { governance, agent1, agent2, agent3, victim } = await loadFixture(deployFixture);

      await governance.connect(agent1).proposeQuorum(
        [agent1.address, agent2.address, agent3.address],
        [34, 33, 33],
        "Gov Test",
        "GOVTEST",
        "Gov thesis"
      );
      await governance.connect(agent2).approveQuorum(0);
      await governance.connect(agent3).approveQuorum(0);

      await governance.connect(agent1).propose(1, 0, victim.address, 10, "0x", "Add victim");

      await governance.connect(agent1).vote(0, true);

      await expect(
        governance.connect(agent1).vote(0, true)
      ).to.be.revertedWith("Already voted");
    });

    it("ATTACK: Execute proposal without majority - should fail", async function () {
      const { governance, agent1, agent2, agent3, victim } = await loadFixture(deployFixture);

      await governance.connect(agent1).proposeQuorum(
        [agent1.address, agent2.address, agent3.address],
        [34, 33, 33],
        "Gov Test",
        "GOVTEST",
        "Gov thesis"
      );
      await governance.connect(agent2).approveQuorum(0);
      await governance.connect(agent3).approveQuorum(0);

      await governance.connect(agent1).propose(1, 0, victim.address, 10, "0x", "Add victim");

      // Only one vote (34% weight) - not majority
      await governance.connect(agent1).vote(0, true);

      // Wait for deadline
      await ethers.provider.send("evm_increaseTime", [3 * 24 * 60 * 60 + 1]);
      await ethers.provider.send("evm_mine", []);

      await expect(
        governance.connect(agent1).execute(0)
      ).to.be.revertedWith("Quorum not reached");
    });
  });

  // ============ EDGE CASE ATTACKS ============
  describe("Edge Case Attacks", function () {
    it("ATTACK: Create market with all weight to one agent - must sum to 100", async function () {
      const { factory, agent1, agent2, agent3 } = await loadFixture(deployFixture);

      // Try 100/0/0 - would give all tokens to agent1
      await expect(
        factory.createMarket(
          [agent1.address, agent2.address, agent3.address],
          [100, 0, 0],
          "Centralized",
          "CENT",
          "All to one"
        )
      ).to.not.be.reverted; // This is valid! Weights sum to 100

      // But duplicate agents are blocked
      await expect(
        factory.createMarket(
          [agent1.address, agent1.address, agent1.address],
          [34, 33, 33],
          "Same Agent",
          "SAME",
          "Same agent 3x"
        )
      ).to.be.revertedWith("Duplicate agents");
    });

    it("ATTACK: Create market with empty strings - allowed (no validation)", async function () {
      const { factory, agent1, agent2, agent3 } = await loadFixture(deployFixture);

      // Empty name/symbol/thesis
      await expect(
        factory.createMarket(
          [agent1.address, agent2.address, agent3.address],
          [34, 33, 33],
          "",
          "",
          ""
        )
      ).to.not.be.reverted;
    });

    it("ATTACK: Buy exact minimum amount - should work", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      const minPurchase = await factory.MIN_PURCHASE();

      await expect(
        factory.connect(attacker).buy(0, 0, { value: minPurchase })
      ).to.not.be.reverted;
    });

    it("ATTACK: Buy 1 wei below minimum - should fail", async function () {
      const { factory, attacker } = await loadFixture(deployFixture);

      const minPurchase = await factory.MIN_PURCHASE();

      await expect(
        factory.connect(attacker).buy(0, 0, { value: minPurchase - 1n })
      ).to.be.revertedWith("Below minimum purchase");
    });
  });

  // ============ TREASURY SECURITY ============
  describe("Treasury Security", function () {
    it("VERIFY: Treasury receives fees on every buy", async function () {
      const { factory, victim, treasury } = await loadFixture(deployFixture);

      const treasuryBefore = await ethers.provider.getBalance(treasury.address);
      const buyAmount = ethers.parseEther("2.0");
      const expectedFee = (buyAmount * 50n) / 10000n;

      await factory.connect(victim).buy(0, 0, { value: buyAmount });

      const treasuryAfter = await ethers.provider.getBalance(treasury.address);
      expect(treasuryAfter - treasuryBefore).to.equal(expectedFee);
    });

    it("VERIFY: Treasury receives fees on every sell", async function () {
      const { factory, token, victim, treasury } = await loadFixture(deployFixture);

      await factory.connect(victim).buy(0, 0, { value: ethers.parseEther("2.0") });
      const balance = await token.balanceOf(victim.address);
      await token.connect(victim).approve(factory.target, balance);

      const expectedEth = await factory.calculateSaleReturn(0, balance);
      const expectedFee = (expectedEth * 50n) / 10000n;

      const treasuryBefore = await ethers.provider.getBalance(treasury.address);
      await factory.connect(victim).sell(0, balance, 0);
      const treasuryAfter = await ethers.provider.getBalance(treasury.address);

      expect(treasuryAfter - treasuryBefore).to.equal(expectedFee);
    });

    it("VERIFY: Only owner can change treasury address", async function () {
      const { factory, owner, attacker } = await loadFixture(deployFixture);

      // Attacker fails
      await expect(
        factory.connect(attacker).setProtocolTreasury(attacker.address)
      ).to.be.revertedWithCustomError(factory, "OwnableUnauthorizedAccount");

      // Owner succeeds
      await expect(
        factory.connect(owner).setProtocolTreasury(owner.address)
      ).to.not.be.reverted;

      expect(await factory.protocolTreasury()).to.equal(owner.address);
    });

    it("VERIFY: Zero address cannot be set as treasury", async function () {
      const { factory, owner } = await loadFixture(deployFixture);

      await expect(
        factory.connect(owner).setProtocolTreasury(ethers.ZeroAddress)
      ).to.be.revertedWith("Zero address");
    });
  });
});
